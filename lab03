.data
inbuf:	.space	64
outbuf: .space	64
Incounter: .long 0
Outcounter: .long 0
	.text
	.global	main
main:
	pushq	$0
   
	call 	inImage # camelcase inImage
    call    getInt
    call    outImage
inImage:
	leaq 	inbuf, %rdi
	movq	$5, %rsi
	movq	stdin, %rdx
	call	fgets
	movq	$0, Incounter
	ret

#
# getInt gör nu som den ska för kontroll av siffror samt multiplikation och konvertering.
#

getInt:
	movq    $inbuf, %rdi
	movq    Incounter,%rax
	movq    $0, %r9
	movq	$0, %r8			# %r8 = flagga för negativt eller positivt tal
	movq    $0, %rbx		# rbx = register för heltal som ska returneras
inbufloop:
	cmpq    $64, %rax
	jne     getIntLoop
	pushq   %rdi
	call    inImage
	popq    %rdi
getIntLoop:
	movb    (%rdi, %r9), %r10b
	cmp     $'', %r10b
	jne	checkBlank
	pushq	%rdi
	call	inImage
	popq	%rdi
checkBlank:
	movb    (%rdi, %r9), %r10b
	cmp     $' ', %r10b
	jne     checkNegative
	incq    %r9
	incq    %rax
	je      inbufloop
checkNegative:
	cmp     $'-', %r10b
	jne     checkPlus
	movq	$1, %r8
	incq    %r9
	incq    %rax
	je      getNumber
checkPlus:
	cmp     $'+', %r10b
	jne     getNumber
	movq	$0, %r8
	incq    %r9
	incq    %rax
getNumber:
	cmpq    $64, %rax
	jne     getNumberLoop
	pushq   %rdi
	call    inImage
	popq    %rdi
getNumberLoop:
	movb    (%rdi, %r9), %r10b
	cmp     $'9', %r10b
	jg      getIntEnd
	cmp     $'0', %r10b
	jl      getIntEnd
	movzbq	%r10b, %r10
	subq	$'0', %r10
	movq    %r10, %r12
	imulq	$10, %rbx		# rbx initialiserat till 0, därav 0 * 10 för första siffran
	addq	%r12, %rbx
nextNumber:
	incq    %rax
	incq    %r9
	jmp     getNumber
getIntEnd:
	cmpq	$1, %r8			# om r8 = 1, invertera. om r8 = 0, returnera talet direkt.
	jne	getIntReturn
	negq	%rbx
getIntReturn:
	movq	%rax, Incounter
	ret
	
	
getText:
    movq    0,%rax
    movq    $inbuf, %rdi 		# flyttar buf till rdi
	movq	Incounter,%rdx		# returnerar vad som står i counter
	movb    (%rdi, %rsi), %r10b
	cmpq    %rax,%rsi
	jne     textLoop
	ret
textLoop:
	movb    (%rdi, %rsi), %r10b
    cmpq    %rax,%rsi
	je      ret
	incq    rax
	call    textLoop


  
getChar:
	movq    $inbuf, %rsi 		# flyttar buf till rdi
	movq	Incounter,%rdx		# returnerar vad som står i counter
	movq    (%rsi, %rdx), %rax
	cmpq    0,%rax
	je      inImage
	cmpq    '64',%rdx
	je      inImage
	incq    %rdx

getInPos:
	movq	Incounter,%rax		# flyttar incounter till rax, returnerar.
    	ret
setInPos:
	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
	jl	lessthanzero
	cmpq	$64,%rdi			# kollar ifall det är större än 64
	jg	largerthanzero
	movq    %rdi, Outcounter
	ret
lessthanzero:
	movq	$0,%rdi 			# rdi blir 0
	ret
largerthanzero:
	movq	$64,%rdi			# rdi blir 64
	ret
	
outImage:
	leaq 	outbuf, %rdi
	movq	Outcounter, %rax
	movb	$0, (%rdi, %rax)    	# nullterminering av sträng
    	call    puts                	# anropar puts, rdi pekar på outbuf
	movq	$0, Outcounter      	# nollställ Outcounter
	ret
putInt:
	movq    $outbuf, %rsi
	call	getOutPos
	movq	%rax, %r9
outIntLoop:
	cmpq	$64, %rax
	jne     putIntLoop
	pushq	%rdi			# pushar rdi, rdi är input parameter med text
	pushq	%rax            	# rax = outcounter
	call    outImage
	popq 	%rax
	popq 	%rdi
putIntLoop:
	movb    (%rdi,%r9), %r10b       # itererar rdi, r10b är nästa char (8 bit)
	cmp	$0, %r10b               # compare, 0 = slut på nullterm. sträng
	je	putIntEnd
	movb 	%r10b, (%rsi, %rax)     # lägg char i utbuffert
	incq	%r9                     # öka index i text
	incq	%rax                    # öka index i utbuffert
	jne     outIntLoop
putIntEnd:
	movq 	%rax, Outcounter        # uppdatera outcounter
	ret

putText:
	movq    $outbuf, %rsi
	call	getOutPos		# returvärde = %rax(aktuell position i utbuffert)
	movq	%rax, %r9		# kopierar aktuell position till %r9
outBufLoop:
	cmpq	$64, %rax
	jne     putTextLoop
	pushq	%rdi			# pushar rdi, rdi är input parameter med text/inbuffert
	pushq	%rax            	# rax = outcounter
	call    outImage
	popq 	%rax
	popq 	%rdi
putTextLoop:
	movb    (%rdi,%r9), %r10b       # itererar rdi, r10b är nästa char (8 bit)
	cmp	$0, %r10b               # compare, 0 = slut på nullterm. sträng
	je	putTextEnd
	movb 	%r10b, (%rsi, %rax)     # lägg char i utbuffert
	incq	%r9                     # öka index i text
	incq	%rax                    # öka index i utbuffert
	jne     outBufLoop
putTextEnd:
	movq 	%rax, Outcounter        # uppdatera outcounter
	ret

putChar:
	movq	$outbuf, %rsi
	call	getOutPos
	movq	%rax, %r9
outCharLoop:
	cmpq	$64, %rax
	jne	putCharLoop
	pushq	%rdi
	pushq	%rax
	call	outImage
	popq	%rax
	popq	%rdi
putCharLoop:
	movb	(%rdi,%r9), %r10b
	cmp	$0, %r10b
	je	putCharEnd
	movb	%r10b, (%rsi, %rax)
	incq	%rax
putCharEnd:
	movq	%rax, Outcounter
	ret

getOutPos:
    	movq	Outcounter,%rax		# returnerar vad som står i counter
    	ret

setOutPos:
    	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
    	jl	Outlessthanzero
    	cmpq	$64,%rdi			# kollar ifall det Ã¤r större Ã¤n 64
    	jg	Outlargerthanzero
    	movq	%rdi, Outcounter	# Ändra värdet på counter
    	ret
Outlessthanzero:
    	movq	$0,%rdi 			# rdi blir 0
    	ret
Outlargerthanzero:
    	movq	$64,%rdi			# rdi blir 64
    	ret	
