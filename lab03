.data
inbuf:	.space	64
outbuf: .asciz "%d\n"
Incounter: .long 0
Outcounter: .long 0
	.text
	.global	main
main:
	pushq	$0
   
	call 	inImage # camelcase inImage
    call    getInt
    call    outImage
inImage:
	leaq	Incounter,	%rbx  # nollställ incounter och ta in input
	movq	$0,%rbx
	movq	$inbuf, %rdi
	movq	$5, %rsi
	movq	stdin, %rdx
	call	fgets
getInt:
	leaq	inbuf, %rdi  # gör r10 till inbufs nuvarande värde.
	movq    Incounter,%rax
    	movzbq  (%rdi,%rax,1), %r10
	cmpq	$32, %r10
	je		continueloop
	cmpq	$43, %r10
	je		continueloop
	cmpq	$45, %r10
	je		continueloop
	call	checkifInt
checkifInt:
	cmpq	$48, %r10	# Kollar ifall r10 är en siffra
	jle		checkifnumber	
	call     endloop
checkifnumber:
	cmpq	$57, %r10
	jle		continueloop
	call     endloop
continueloop:
	movq	$outbuf,%r8     # Lägger till nuvarande tal i outbuf.
	movq    $Outcounter,%rax
	movq	%r10,(%r8,%rax,8)
	incq	%rax            # ökar counter med ett
	call	checkifInt
endloop:
   	movq	$outbuf,%rax 
	
getText:
	movq    $inbuf, %rdi  		# kopiera/flytta buf till rdi
	call    inImage     		# anropar inImage för att ta emot sträng och nollställa position i buf (counter)
	call    addText   			# subrutin för att lägga till text till format
addText:
	movq	(%rdi, %r8), %rdi
	pushq	%rdi	
	incq	%r8					# aktuell position
	cmpq	%r8, %r9			# jämför aktuell position med parameter 1
	je		endloop				# om lika, gå till endloop för avslut
	call	addText				# lägg till nästa tecken i buf


  
getChar:
	movq    $inbuf, %rdi 		# flyttar buf till rdi
	cmpq	$0,%rdi				# Ifall ord saknas eller är i slutet är sista tecken \n.
	je		inImage
	movq	(%rdi,%r8),%rax 	# tar nuvarande bokstav
	incq	%r8					#  ökar med 1

getInPos:
	movq	$Incounter,%rax		# returnerar vad som står i counter

setInPos:
	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
	jl		lessthanzero
	cmpq	$64,%rdi			# kollar ifall det är större än 64
	jg		largerthanzero
	movq	$Incounter, %rdi	# ändra värdet på counter
lessthanzero:
	movq	$0,%rdi 			# rdi blir 0
	call	setInPos
largerthanzero:
	movq	$64,%rdi			# rdi blir 64
	call 	setInPos
	
outImage:
    movq    $inbuf, %rdi
    movq    $5, %rsi
    movq    stdout,%rdx
    call    puts
    leaq	Outcounter,	%rbx
	movq	$0,%rbx

putInt:
    movq    $outbuf,%rdx
    movq    $Outcounter,%r8
    movq	(%rdx, %r8), %rdx
    cmpq	$0,%rdx				# Ifall ord saknas eller är i slutet är sista tecken \n.
	je		inImage
	movq	(%rdx,%r8),%rdi 	# tar nuvarande bokstav
	incq	%r8					#  ökar med 1

putText:
    movq    $outbuf,%rsi
    movq    $Outcounter,%rax
    jmp     outBufLoop
outBufLoop:
    cmpq    $64, %rax				# om räknare ej 64, lägg till tecken i utbuffert
    jne     putTextLoop
    call    outImage
    jmp     putTextLoop
putTextLoop:
    movq    (%rdi,%rax),%rsi			# ger segmentation fault ...
    incq    %rax
    cmpq    $0, %rsi
    jne     outBufLoop
    ret

# samtliga nedan identiska med inbuffert-position, med namn för utbuffert istället
# vid ändring av syntax för inbuffert-funktioner, ändra här också
getOutPos:
    movq	$Outcounter,%rax		# returnerar vad som står i counter
    ret
setOutPos:
    cmpq	$0,%rdi				# kollar ifall det är mindre än noll
    jl		Outlessthanzero
    cmpq	$64,%rdi			# kollar ifall det Ã¤r större Ã¤n 64
    jg		Outlargerthanzero
    movq	$Outcounter, %rdi	# Ändra värdet på counter
Outlessthanzero:
    movq	$0,%rdi 			# rdi blir 0
    call	setOutPos
Outlargerthanzero:
    movq	$64,%rdi			# rdi blir 64
    call 	setOutPos
