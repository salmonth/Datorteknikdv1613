.data
inbuf:	.space	64
outbuf: .space	64
Incounter: .long 0
Outcounter: .long 0
	.text
	.global	main
main:
	pushq	$0
   
	call 	inImage # camelcase inImage
    call    getInt
    call    outImage
inImage:
	leaq 	inbuf, %rdi
	movq	$5, %rsi		# byta ut 5 mot andra argumentet i inmatningsfunktioner, dvs max antal tecken?
	movq	stdin, %rdx
	call	fgets
	movq	$0, Incounter
	ret

#
# getInt gör nu som den ska för kontroll av siffror samt multiplikation och konvertering.
# TODO:
#	andra argumentet ska vara maximalt antal tecken som ska överföras,
#	ska göra justering för detta i början av getInt
#

getInt:
	movq    $inbuf, %rdi
	movq    Incounter,%rax
	movq    $0, %r9
	movq	$0, %r8			# %r8 = flagga för negativt eller positivt tal
	movq    $0, %rbx		# rbx = register för heltal som ska returneras
inbufloop:
	cmpq    $64, %rax
	jne     getIntLoop
	call    inImage
	movq	$inbuf, %rdi
getIntLoop:
	movb    (%rdi, %r9), %r10b
	cmp     $'', %r10b
	jne	checkBlank
	call	inImage
	movq	$inbuf, %rdi
checkBlank:
	movb    (%rdi, %r9), %r10b
	cmp     $' ', %r10b
	jne     checkNegative
	incq    %r9
	incq    %rax
	jmp	inbufloop
checkNegative:
	cmp     $'-', %r10b
	jne     checkPlus
	movq	$1, %r8
	incq    %r9
	incq    %rax
	jmp     getNumber
checkPlus:
	cmp     $'+', %r10b
	jne     getNumber
	movq	$0, %r8
	incq    %r9
	incq    %rax
getNumber:
	cmpq    $64, %rax
	jne     getNumberLoop
	call    inImage
	movq	$inbuf, %rbx
getNumberLoop:
	movb    (%rdi, %r9), %r10b
	cmp     $'9', %r10b
	jg      getIntEnd
	cmp     $'0', %r10b
	jl      getIntEnd
	movzbq	%r10b, %r10		# teckenutfyllnad
	subq	$'0', %r10		# konvertering
	movq    %r10, %r12
	imulq	$10, %rbx		# rbx initialiserat till 0, därav 0 * 10 för första siffran
	addq	%r12, %rbx		# lägg till aktuell, konverterad siffra i inbuffert till rbx
nextNumber:
	incq    %rax
	incq    %r9
	jmp     getNumber
getIntEnd:
	cmpq	$1, %r8			# om r8 = 1, invertera. om r8 = 0, returnera talet direkt.
	jne	getIntReturn
	negq	%rbx
getIntReturn:
	movq	%rax, Incounter
	movq	%rbx, %rax		# flyttar heltalet i rbx till rax enligt konvention
	ret

getText:
    movq    %rdi, %rcx
    movq    $inbuf, %rdi
    movq    $Incounter, %rax
    movq    %rax, %r9
    movq    %rsi, %r8
    movq    $0, %r11
getCharRpt:
    xorq    %rax, %rax
    call    getChar
    movb    %al,(%rcx, %r11)
    incq    %r11
    incq    %r9
    movq    %r9, Incounter
    cmpq    %r8, %r11
    jl      getCharRpt
getTextEnd:
    movq    %r11, %rax
    ret

getChar:
    movq    $inbuf, %rdi
    movq    $Incounter,%r9
getCharBufLoop:
    cmpq    $64, %r9
    jne     checkCharEmpty
    call    inImage
    movq    $inbuf, %rdi
    movq    $Incounter, %r9
checkCharEmpty:
    cmpq    $0, %rdi
    jne     returnChar
    call    inImage
    movq    $inbuf, %rdi
    movq    $Incounter, %r9
returnChar:
    movq    %rdi, %rdx
    movb    %dl, %r10b
    movzbq	%r10b, %r10
    incq    %r9
    movq    %r9, Incounter
    xorq    %rax, %rax
    movq    %r10, %rax
    ret

getInPos:
	movq	Incounter,%rax		# flyttar incounter till rax, returnerar.
    	ret

setInPos:
	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
	jl	lessthanzero
	cmpq	$64,%rdi			# kollar ifall det är större än 64
	jg	largerthanzero
	movq    %rdi, Incounter			# bytte till Incounter från Outcounter
	ret
lessthanzero:
	movq	$0,%rdi 			# rdi blir 0
	movq    %rdi, Incounter
	ret
largerthanzero:
	movq	$64,%rdi			# rdi blir 64
	movq    %rdi, Incounter			# flyttar Maxpos till incounter
	ret

###
# rutiner för utmatning:
###

outImage:
	leaq 	outbuf, %rdi
	movq	Outcounter, %rax
	movb	$0, (%rdi, %rax) 	# strängen måste vara nullterminerad vid utskrift, måste ligga innan puts
    	call    puts                	# anropar puts, rdi pekar på outbuf
	movq	$0, Outcounter      	# nollställ Outcounter
	ret

# putInt fungerar

putInt:
	movq    %rdi, %rdx
	movq    $outbuf, %rsi
	movq    $0, %r8
	movq    $0, %r9
	movq    $10, %r11
	xorq    %rax, %rax
	movq    %rdx, %rax
putIntLoop:
	xorq    %rdx, %rdx
	idivq   %r11
	addq    $48, %rdx
	pushq   %rdx
	subq    $48, %rdx
	incq    %r8
	cmpq    $0, %rax
	jg      putIntLoop
	call    getOutPos
outIntLoop:
	cmpq	$64, %rax
	jne     addToOutbuf
	pushq	%rdi
	pushq	%rax
	call    outImage
	popq 	%rax
	popq 	%rdi
addToOutbuf:
	popq    %rdx
	movb    %dl, %r10b
	movb 	%r10b, (%rsi, %rax)
	decq    %r8
	incq    %r9
	incq    %rax
	cmpq    $0,%r8
	je      putIntEnd
	jmp     outIntLoop
putIntEnd:
	movq 	%rax, Outcounter
	ret

putText:
	movq    $outbuf, %rsi
	call	getOutPos		# returvärde = %rax(aktuell position i utbuffert)
	movq	%rax, %r9		# kopierar aktuell position till %r9
outBufLoop:
	cmpq	$64, %rax
	jne     putTextLoop
	pushq	%rdi			# pushar rdi, rdi är input parameter med text/inbuffert
	pushq	%rax            	# rax = outcounter
	call    outImage
	popq 	%rax
	popq 	%rdi
putTextLoop:
	movb    (%rdi,%r9), %r10b       # itererar rdi, r10b är nästa char (8 bit)
	cmp	$0, %r10b               # compare, 0 = slut på nullterm. sträng
	je	putTextEnd
	movb 	%r10b, (%rsi, %rax)     # lägg char i utbuffert
	incq	%r9                     # öka index i text
	incq	%rax                    # öka index i utbuffert
	cmpq	$0, %rsi
	jne     outBufLoop
putTextEnd:
	movq 	%rax, Outcounter        # uppdatera outcounter
	ret

putChar:
	movq	$outbuf, %rsi
	call	getOutPos
	movq	%rax, %r9
outCharLoop:
	cmpq	$64, %rax
	jne	putCharLoop
	pushq	%rdi
	pushq	%rax
	call	outImage
	popq	%rax
	popq	%rdi
putCharLoop:
	movb	(%rdi,%r9), %r10b
	cmp	$0, %r10b
	je	putCharEnd
	movb	%r10b, (%rsi, %rax)
	incq	%rax
putCharEnd:
	movq	%rax, Outcounter
	ret

getOutPos:
    	movq	Outcounter,%rax		# returnerar vad som står i counter
    	ret

setOutPos:
    	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
    	jl	Outlessthanzero
    	cmpq	$64,%rdi			# kollar ifall det Ã¤r större Ã¤n 64
    	jg	Outlargerthanzero
    	movq	%rdi, Outcounter	# Ändra värdet på counter
    	ret
Outlessthanzero:
    	movq	$0,%rdi 			# rdi blir 0
	movq	%rdi, Outcounter
    	ret
Outlargerthanzero:
    	movq	$64,%rdi			# rdi blir 64
	movq	%rdi, Outcounter
    	ret	
