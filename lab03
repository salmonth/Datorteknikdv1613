.data
inbuf:	.space	64
outbuf: .space	64			# outbuf ska också vara reserverat utrymme, nullterm. sker i in/outImage
Incounter: .long 0
Outcounter: .long 0
	.text
	.global	main
main:
	pushq	$0
   
	call 	inImage # camelcase inImage
    call    getInt
    call    outImage
inImage:
	leaq 	inbuf, %rdi
	movq	Incounter, %rax
	movq	$5, %rsi
	movq	stdin, %rdx
	call	fgets
	movq	$0, Incounter      	# nollställ Incounter
	ret

# har inte hunnit testa getInt än, men den visar hur jag har tänkt.

getInt:
	movq    inbuf, %rcx
	movq    Incounter,%rax
	movq    %rax, %r9
	movq    $0, %r11		# r11 = räknare för antal siffror
	movq	$0, %r8			# %r8 = flagga för negativt eller positivt tal, 1 = negativt 0 = positivt
inbufloop:
	cmpq    $64, %rax
	jne     getIntLoop
	pushq   %rdi
	pushq   %rax
	call    outImage
	popq    %rax
	popq    %rdi
getIntloop:
	movb    (%rdi, %r9), %r10b
	cmp     $0, %r10b
	je      getIntEnd
	cmp     $32, %r10b
	jne     checkNegative
	incq    %r9
	incq    %rax
	je      inbufloop
checkNegative:
	cmp     $'-', %r10b
	jne     checkPlus
	movq	$1, %r8
	incq    %r9
	incq    %rax
	je      getNumber
checkPlus:
	cmp     $'+', %r10b
	jne     getNumber
	movq	$0, %r8
	incq    %r9
	incq    %rax
getNumber:
	cmpq    $64, %rax
	jne     getPositiveLoop
	pushq   %rax
	pushq   %rdi
	call    outImage
	popq    %rdi
	popq    %rax
getNumberLoop:
	movb    (%rdi, %r9), %r10b
	cmp     $'9', %r10b
	jg      getIntEnd
	cmp     $'0', %r10b
	jl      getIntEnd
	movzbq	%r10b, %r10
	sub	%r10, $'0', %r12			# r12 = siffra som ska konverteras till heltal
	cmpq	$0, %r11
	jg	multiplyNumber
	addq	%r12, %rbx
	je	nextNumber
multiplyNumber:
	imulq	$10, %rbx
	addq	%r12, %rbx
nextNumber:
	incq    %rax
	incq    %r9
	incq	%r11
	jmp     getNumber
getIntEnd:
	cmpq	$1, %r8
	jne	getIntReturn
	negq	%rbx
getIntReturn:
	movq	%rax, Incounter
	ret
	
	
getText:
	movq    $inbuf, %rdi  		# kopiera/flytta buf till rdi
	call    inImage     		# anropar inImage för att ta emot sträng och nollställa position i buf (counter)
	call    addText   			# subrutin för att lägga till text till format
addText:
	movq	(%rdi, %r8), %rdi
	pushq	%rdi	
	incq	%r8					# aktuell position
	cmpq	%r8, %r9			# jämför aktuell position med parameter 1
	je		endloop				# om lika, gå till endloop för avslut
	call	addText				# lägg till nästa tecken i buf


  
getChar:
	movq    $inbuf, %rsi 		# flyttar buf till rdi
	movq	Incounter,%rdx		# returnerar vad som står i counter   
	cmpq    $64,%rax
	je     inImage
	movb    (%rdi,%rdx), %r10b# itererar rdi, r10b är nästa char (8 bit

getInPos:
	movq	Incounter,%rax		# flyttar incounter till rax, returnerar.
    	ret
setInPos:
	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
	jl	lessthanzero
	cmpq	$64,%rdi			# kollar ifall det är större än 64
	jg	largerthanzero
	movq    %rdi, Outcounter
	ret
lessthanzero:
	movq	$0,%rdi 			# rdi blir 0
	ret
largerthanzero:
	movq	$64,%rdi			# rdi blir 64
	ret
	
outImage:
	leaq 	outbuf, %rdi
	movq	Outcounter, %rax
	movb	$0, (%rdi, %rax)    	# nullterminering av sträng
    	call    puts                	# anropar puts, rdi pekar på outbuf
	movq	$0, Outcounter      	# nollställ Outcounter
	ret
putInt:
	movq    $outbuf, %rsi
	call	getOutPos
	movq	%rax, %r9
outIntLoop:
	cmpq	$64, %rax
	jne     putIntLoop
	pushq	%rdi			# pushar rdi, rdi är input parameter med text
	pushq	%rax            	# rax = outcounter
	call    outImage
	popq 	%rax
	popq 	%rdi
putIntLoop:
	movb    (%rdi,%r9), %r10b       # itererar rdi, r10b är nästa char (8 bit)
	cmp	$0, %r10b               # compare, 0 = slut på nullterm. sträng
	je	putIntEnd
	movb 	%r10b, (%rsi, %rax)     # lägg char i utbuffert
	incq	%r9                     # öka index i text
	incq	%rax                    # öka index i utbuffert
	jne     outIntLoop
putIntEnd:
	movq 	%rax, Outcounter        # uppdatera outcounter
	ret

putText:
	movq    $outbuf, %rsi
	call	getOutPos		# returvärde = %rax(aktuell position i utbuffert)
	movq	%rax, %r9		# kopierar aktuell position till %r9
outBufLoop:
	cmpq	$64, %rax
	jne     putTextLoop
	pushq	%rdi			# pushar rdi, rdi är input parameter med text/inbuffert
	pushq	%rax            	# rax = outcounter
	call    outImage
	popq 	%rax
	popq 	%rdi
putTextLoop:
	movb    (%rdi,%r9), %r10b       # itererar rdi, r10b är nästa char (8 bit)
	cmp	$0, %r10b               # compare, 0 = slut på nullterm. sträng
	je	putTextEnd
	movb 	%r10b, (%rsi, %rax)     # lägg char i utbuffert
	incq	%r9                     # öka index i text
	incq	%rax                    # öka index i utbuffert
	jne     outBufLoop
putTextEnd:
	movq 	%rax, Outcounter        # uppdatera outcounter
	ret

putChar:
	movq	$outbuf, %rsi
	call	getOutPos
	movq	%rax, %r9
outCharLoop:
	cmpq	$64, %rax
	jne	putCharLoop
	pushq	%rdi
	pushq	%rax
	call	outImage
	popq	%rax
	popq	%rdi
putCharLoop:
	movb	(%rdi,%r9), %r10b
	cmp	$0, %r10b
	je	putCharEnd
	movb	%r10b, (%rsi, %rax)
	incq	%rax
putCharEnd:
	movq	%rax, Outcounter
	ret

getOutPos:
    	movq	Outcounter,%rax		# returnerar vad som står i counter
    	ret

setOutPos:
    	cmpq	$0,%rdi				# kollar ifall det är mindre än noll
    	jl	Outlessthanzero
    	cmpq	$64,%rdi			# kollar ifall det Ã¤r större Ã¤n 64
    	jg	Outlargerthanzero
    	movq	%rdi, Outcounter	# Ändra värdet på counter
    	ret
Outlessthanzero:
    	movq	$0,%rdi 			# rdi blir 0
    	ret
Outlargerthanzero:
    	movq	$64,%rdi			# rdi blir 64
    	ret	
