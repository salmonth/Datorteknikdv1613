	.data
counter:	.quad 0
GPIO:		.quad 0
	.text
	.global setup
	.global interrupt
.text
.global main
main:
    call interrupt
    call setup
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
	ret

interrupt:
# count up the counter from 0 to 15 modulo 16
movq	counter, %rbx
incq	%rbx
andq	$0xf, %rbx
movq	%rbx, counter
cmpq	$1, %rbx
je	one
cmpq	$2, %rbx
je   two
cmpq  $3, %rbx
je   three
cmpq  $4, %rbx
je   four
cmpq  $5, %rbx
je   five
cmpq  $6, %rbx
je   six
cmpq  $7, %rbx
je   seven
cmpq  $8, %rbx
je   eight
cmpq  $9, %rbx
je   nine
cmpq  $10, %rbx
je   ten
cmpq  $11, %rbx
je   eleven
cmpq  $12, %rbx
je   twelve
cmpq  $13, %rbx
je   thirteen
cmpq  $14, %rbx
je   fourteen
cmpq  $15, %rbx
je   fifteen

one:
call	LightOne
ret
two:
call 	LightTwo
ret
three:
call LightOne
call LightTwo
ret
four:
call LightFour
ret
five:
call LightOne
call LightFour
ret
six:
call LightTwo
call LightFour
ret
seven:
call LightOne
call LightTwo
call LightFour
ret
eight:
call LightEight
ret
nine:
call LightOne
call LightEight
ret
ten:
call LightTwo
call LightEight
ret
eleven:
call LightOne
call LightTwo
call LightEight
ret
twelve:
call LightFour
call LightEight
ret
thirteen:
call LightOne
call LightFour
call LightEight
ret
fourteen:
call LightTwo
call LightFour
call LightEight
ret
fifteen:
call LightOne
call LightTwo
call LightFour
call LightEight
ret

LightOne:
# set first GPIO pin to high level (LED on)
movq	GPIO, %r9
movq	$1, %rcx
subq	$1,	%rcx
imulq	$8, %rcx
movq	$0x3, %rbx
shlq	$4, %rbx
addq	$1, %rbx
shlq	%cl, %rbx
orq	%rbx, 3(%r9)
ret

LightTwo:
# set second GPIO pin to high level (LED on)
movq    GPIO, %r9            # Load GPIO memory address
movq    $2, %rcx         	# Load the GPIO number into %rcx
subq    $1, %rcx            # Adjust to 0-based indexing
imulq   $8, %rcx			# Multiply by 8
movq    $0x3, %rbx			# Set value 0x3
shlq    $4, %rbx			# Shift value 0x3 by 4 bits
addq    $1, %rbx			# Add 1 to the result
shlq    %cl, %rbx            # Shift left based on GPIO number
orq	%rbx, 3(%r9)			# Combine with the existing value
ret

LightFour:
# set third GPIO pin to high level (LED on)
movq    GPIO, %r9            # Load GPIO memory address
movq    $3, %rcx         	# Load the GPIO number into %rcx
subq    $1, %rcx             # Adjust to 0-based indexing
imulq   $8, %rcx             # Multiply by 8
movq    $0x3, %rbx           # Set value 0x3
shlq    $4, %rbx             # Shift value 0x3 by 4 bits
addq    $1, %rbx             # Add 1 to the result
shlq    %cl, %rbx            # Shift left based on GPIO number
orq	%rbx, 3(%r9)			# Combine with the existing value
ret

LightEight:
# set fourth GPIO pin to high level (LED on)
movq    GPIO, %r9            # Load GPIO memory address
movq    $4, %rcx			# Load the GPIO number into %rcx
subq    $1, %rcx             # Adjust to 0-based indexing
imulq   $8, %rcx             # Multiply by 8
movq    $0x3, %rbx           # Set value 0x3
shlq    $4, %rbx             # Shift value 0x3 by 4 bits
addq    $1, %rbx             # Add 1 to the result
shlq    %cl, %rbx            # Shift left based on GPIO number
orq	%rbx, 3(%r9)			# Combine with the existing value
ret

### turn off ights
turnoff_one:
movq	GPIO, %r9			# Load Gpio memory address
movq	$0xCF, %rbx			# Set value 0xCF 
movq	$1, %rcx			# Move gpio_nr to rcx
subq	$1, %rcx			# Sub 1 from GPIO nr
imulq	$8, %rcx			# Multiply result by 8
shlq	%cl, %rbx			# Shift left based on GPIO number
notq	%rbx				# Invert shift result
andq	%rbx, 3(%r9)			# Combine with existing value (gpio_addr + 3)
ret

turnoff_two:
movq	GPIO, %r9
movq	$0xCF, %rbx
movq	$2, %rcx
subq	$1, %rcx
imulq	$8, %rcx
shlq	%cl, %rbx
notq	%rbx
andq	%rbx, 3(%r9)
ret

turnoff_four:
movq	GPIO, %r9
movq	$0xCF, %rbx
movq	$3, %rcx
subq	$1, %rcx
imulq	$8, %rcx
shlq	%cl, %rbx
notq	%rbx
andq	%rbx, 3(%r9)
ret

turnoff_eight:
movq	GPIO, %r9
movq	$0xCF, %rbx
movq	$4, %rcx
subq	$1, %rcx
imulq	$8, %rcx
shlq	%cl, %rbx
notq	%rbx
andq	%rbx, 3(%r9)
ret

setup:
# calculate and save the memory address of the GPIO
movq	$0x60, %rdi
shlq	$16, %rdi
movq    $0xFFFF,%rbx 
andq	$0x1000, %rbx
movq    $0x9E,%r9
not     %r9
andq    $0xFF,%r9
orq     %rdi,%rbx
orq     %rbx,%r9
movq	%r9, GPIO

# Set GPIO pins 1-4 as outputs (index 1-4)
movq	GPIO, %rdi
movq    $1,%rdx
output_loop:
movq    $0x2, %rax   		# Set output value
shlq    $6, %rax     		# Shift to the correct position
movq    $4, %rcx     		# Number of GPIO pins to set
subq    %rdx, %rcx   		# Adjust for the current pin
imulq   $2, %rcx     		# Multiply by 2 (each pin is 2 bits)
shlq    %cl, %rax    		# Shift to the correct position for the current pin
orq     %rax, (%rdi)		# Set the output value for the current pin
incq    %rdx         		# Move to the next pin
cmpq    $4, %rdx     		# Check if all pins are set
jle     output_loop  		# Continue the loop if not

# Set GPIO pin 0 as an input (index 0)
setinput:
movq    $0, %rdx 			# GPIO_NR
movq	$0x3, %rbx
movq    %rdx, %rax
addq    %rax, %rdi
movq	$3, %rcx
subq    %rdx, %rcx
imulq   $2, %rcx
andq    $7, %rcx
addq    $8, %rcx
shlq	%cl, %rbx
orq     %rbx, (%rdi)
ret
