	.data
counter:	.quad 0
GPIO:		.quad 0
	.text
	.global setup
	.global interrupt
.text
.global main
main:
    call interrupt
    call setup
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
        call interrupt
	ret





interrupt:
	#count up the counter from 0 to 15 modulo 16
	movq	counter, %rbx
	incq	%rbx
	andq	$0xf, %rbx
	movq	%rbx, counter
	cmpq  $1, %rbx
	je   one
	cmpq  $2, %rbx
	je   two
	cmpq  $3, %rbx
	je   three
	cmpq  $4, %rbx
	je   four
	cmpq  $5, %rbx
	je   five
	cmpq  $6, %rbx
	je   six
	cmpq  $7, %rbx
	je   seven
	cmpq  $8, %rbx
	je   eight
	cmpq  $9, %rbx
	je   nine
	cmpq  $10, %rbx
	je   ten
	cmpq  $11, %rbx
	je   eleven
	cmpq  $12, %rbx
	je   twelve
	cmpq  $13, %rbx
	je   thirteen
	cmpq  $14, %rbx
	je   fourteen
	cmpq  $15, %rbx
	je   fifteen
    ret
one:
call LightOne
ret
two:
call LightTwo
ret
three:
call LightOne
call LightTwo
ret
four:
call LightFour
ret
five:
call LightOne
call LightFour
ret
six:
call LightTwo
call LightFour
ret
seven:
call LightOne
call LightTwo
call LightFour
ret
eight:
call LightEight
ret
nine:
call LightOne
call LightEight
ret
ten:
call LightTwo
call LightEight
ret
eleven:
call LightOne
call LightTwo
call LightEight
ret
twelve:
call LightFour
call LightEight
ret
thirteen:
call LightOne
call LightFour
call LightEight
ret
fourteen:
call LightTwo
call LightFour
call LightEight
ret
fifteen:
call LightOne
call LightTwo
call LightFour
call LightEight
ret
LightOne:
# set first GPIO pin to high level (LED on)
movq    GPIO, %r9            # Load GPIO memory address
movq    $1, %rcx         	# Load the GPIO number into %rcx
subq    $1, %rcx             # Adjust to 0-based indexing
imulq   $8, %rcx             # Multiply by 8

movq    $0x3, %rbx           # Set value 0x3
shlq    $4, %rbx             # Shift value 0x3 by 4 bits
addq    $1, %rbx             # Add 1 to the result

shlq    %cl, %rbx            # Shift left based on GPIO number

orq     %rbx, %r9           # Combine with the existing value
movq    %rbx, (GPIO)
# Store the result back to the GPIO memory address
ret
LightTwo:
movq    GPIO, %r9            # Load GPIO memory address
movq    $2, %rcx         	# Load the GPIO number into %rcx
subq    $1, %rcx             # Adjust to 0-based indexing
imulq   $8, %rcx             # Multiply by 8

movq    $0x3, %rbx           # Set value 0x3
shlq    $4, %rbx             # Shift value 0x3 by 4 bits
addq    $1, %rbx             # Add 1 to the result

shlq    %cl, %rbx            # Shift left based on GPIO number

orq     %rbx, %r9           # Combine with the existing value
movq    %rbx, (GPIO)
# Store the result back to the GPIO memory address
ret
LightFour:
movq    GPIO, %r9            # Load GPIO memory address
movq    $3, %rcx         	# Load the GPIO number into %rcx
subq    $1, %rcx             # Adjust to 0-based indexing
imulq   $8, %rcx             # Multiply by 8

movq    $0x3, %rbx           # Set value 0x3
shlq    $4, %rbx             # Shift value 0x3 by 4 bits
addq    $1, %rbx             # Add 1 to the result

shlq    %cl, %rbx            # Shift left based on GPIO number

orq     %rbx, %r9           # Combine with the existing value
movq    %rbx, (GPIO)
# Store the result back to the GPIO memory address
ret
LightEight:
movq    GPIO, %r9            # Load GPIO memory address
movq    $4, %rcx         	# Load the GPIO number into %rcx
subq    $1, %rcx             # Adjust to 0-based indexing
imulq   $8, %rcx             # Multiply by 8

movq    $0x3, %rbx           # Set value 0x3
shlq    $4, %rbx             # Shift value 0x3 by 4 bits
addq    $1, %rbx             # Add 1 to the result

shlq    %cl, %rbx            # Shift left based on GPIO number

orq     %rbx, %r9           # Combine with the existing value
movq    %rbx, (GPIO)
# Store the result back to the GPIO memory address
ret

setup:
# calculate and save the memory address of the GPIO
movq	$0x60, %rdi
shlq	$16, %rdi
movq    $0xFFFF,%rbx 
andq	$0x1000, %rbx
movq    $0x9E,%r9
not     %r9
andq    $0xFF,%r9
orq     %rdi,%rbx
orq     %rbx,%r9
movq	%r9, GPIO


# Set GPIO pins 1-4 as outputs (index 1-4)
movq    $1,%rdx
movq	%r9, %rdi

output_loop:
    movq    $0x2, %rax   # Set output value
    shlq    $6, %rax     # Shift to the correct position
    movq    $4, %rcx     # Number of GPIO pins to set
    subq    %rdx, %rcx   # Adjust for the current pin
    imulq   $2, %rcx     # Multiply by 2 (each pin is 2 bits)
    shlq    %cl, %rax    # Shift to the correct position for the current pin
    orq     (%rdi), %rax # Set the output value for the current pin

    incq    %rdx         # Move to the next pin
    cmpq    $4, %rdx     # Check if all pins are set
    jle     output_loop  # Continue the loop if not

# Set GPIO pin 0 as an input (index 0)
movq    $0, %rsi 	# GPIO_NR
movq	%r9, %rdi	# gpio_adrr
movq	$0x3, %rbx

movq    $8,%r8
movq    %rsi, %rax
xorq	%rdx, %rdx
idivq   %r8
addq    %rax, %rdi

movq	$3, %rcx
subq    %rsi, %rcx
imulq   $2, %rcx
andq    $7, %rcx
addq    $8, %rcx
shlq	%cl, %rbx

orq     (%rdi),%rbx
ret
